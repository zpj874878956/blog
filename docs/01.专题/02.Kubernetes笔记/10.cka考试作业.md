---
title: cka考试作业
date: 2023-06-09 19:13:08
permalink: /pages/e1e25d/
categories:
  - 专题
  - Kubernetes笔记
tags:
  - 
---

### 1、新建命名空间，在该命名空间创建一个pod

命名空间名称：saas

pod名称：pod-01

镜像：nginx

```bash
apiVersion: v1
kind: Pod
metadata:
  name: pod-01
  namespace: saas
spec:
  containers:
  - name: nginx
    image: nginx:latest
```

### 2、创建一个deployment，并暴露service

名称：web

镜像：nginx

```bash
kubectl create deployment web --image=nginx
kubectl expose deploymnet web --port=80 --target-port=80
```

### 3、列出命名空间下指定标签pod

命名空间名称：kube-system

标签：k8s-app=kube-dns

```bash
kubectl get pod -n kube-system -l k8s-app=kube-dns
```

### 4、查看pod日志，并将日志中error的行记录到指定文件

pod名称：web

文件：/opt/web-log

```bash
kubectl logs web | gerp error > /opt/web-log
```

### 5、 查看指定标签使用cpu最高的pod，并记录到到指定文件

标签：app=web

文件：/opt/cpu

```bash
kubectl top pod -l app=web --sort-by="cpu" >/opt/cpu
```

### 6、在节点上配置kubelet托管启动一个pod

节点：k8s-node1

pod名称：web

镜像：nginx

```bash
apiVersion: v1
kind: pod
metadata:
  name: web
  namespace: default
  labels:
    app: myapp
spec:
  containers:
  - name: nginx
    image: nginx
```

### 7、向pod中添加一个init容器，init容器创建一个空文件，如果该空文件没有被检测到，pod就退出

pod名称：web

```bash
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: main-container
    image: your-main-container-image
    readinessProbe:
      exec:
        command:
        - sh
        - -c
        - "[ -f /path/to/empty/file ]"
      initialDelaySeconds: 5
      periodSeconds: 10
  initContainers:
  - name: init-container
    image: your-init-container-image
    command: ["sh", "-c", "touch /path/to/empty/file"]
  # 其他 Pod 配置
```

### 8、创建一个deployment 副本数 3，然后滚动更新镜像 版本，并记录这个更新记录，最后再回滚到上一个版本

名称：nginx

镜像版本：1.16

更新镜像版本：1.17

```bash
kubectl create deployment web --image=nginx:1.16
kubectl set image deployment web nginx=nginx:1.17 --record
kubectl rollout history deply web #查看版本记录
kubectl rollout undo deployment web #回滚到上一个版本
kubectl rollout undo deployment web --to-revision=1 #也可以回滚到指定版本
```

### 9、给web deployment扩容副本数为3

```bash
kubectl scale deployment web --replicas=3
```

### 10、创建一个pod，其中运行着nginx、redis、 memcached、consul 4个容器

```bash
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: nginx
    image: nginx
    # Nginx 容器配置
  - name: redis
    image: redis
    # Redis 容器配置
  - name: memcached
    image: memcached
    # Memcached 容器配置
  - name: consul
    image: consul
    # Consul 容器配置
```

### 11、生成一个deployment yaml文件保存 到/opt/deploy.yaml

名称：web

标签：app_env_stage=dev

```bash
kubectl create deployment web --image=nginx:1.20.2 --dry-run=client -o yaml > deploymnet.yaml
cat deplyment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: web
  name: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dev
  template:
    metadata:
      labels:
        app: dev
    spec:
      containers:
      - image: nginx:1.20.2
        name: nginx
```

### 12、创建一个pod，分配到指定标签node上

pod名称：web

镜像：nginx

node标签：disk=ssd

```bash
apiVersion: v1
kind: Pod
metadata:
  name: web
spec:
  container:
  - name: nginx
    image: nginx:1.20.2
  nodeSelector:
    disk: ssd
```

### 13、确保在每个节点上运行一个pod

名称：filebeat

镜像：elastic/filebeat：7.12.1

```bash
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: filebeat
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: filebeat
  template:
    metadata:
      labels:
        app: filebeat
   spec:
      containers:
      - name: filebeat
        image: docker.elastic.co/beats/filebeat:7.12.1
        # Filebeat 容器配置
        volumeMounts:
        - name: config
          mountPath: /etc/filebeat
          readOnly: true
      volumes:
      - name: config
        configMap:
          name: filebeat-config
```

### 14、查看集群中状态为ready的node数量，不包含被打 了 NodeSchedule污点的节点，并将结果写 到/opt/node.txt

```bash
kubectl describe node $(kubectl get nodes|grep Ready|awk '{print $1}') |grep Taint|grep -vc
NoSchedule > /opt/node.txt
```

### 15、设置成node不能调度，并使已被调度的pod重新调度

```bash
kubectl cordon node1
kubectl drain node1 --ignore-daemonsets
```

### 16、给一个pod创建service，并可以通过ClusterIP访问

名称：web-service

pod名称：web-pod

容器端口：80

```bash
kubectl expose pod web-pod --port=80 --target-port=80 --name=web-service --type=NodePort

kubectl get svc web-service

curl CLUSTER-IP
```

### 17、 任意名称创建deployment和service，然后使用 busybox容器nslookup解析service

```bash
kubectl create deployment nginx-dns --image=nginx
kubectl expose deploymnet nginx-dns --name=nginx-dns --port=80
kubectl run bs-dns --image=busybox:1.28.4 busybox sleep 36000
kubectl exec -it bs-dns --nslookup nginx-dns
```

### 18、列出命名空间下某个service关联的所有pod，并将 pod名称写到/opt/pod.txt文件中（使用标签筛选）

命名空间：default

service名称：web

```bash
kubectl get service web -o yaml
kubectl get pods -l app=web -o name > /opt/pod.txt
```

### 19、创建一个secret，并创建2个pod，pod1挂载该 secret，路径为/etc/foo，pod2使用环境变量引用该 secret，该变量的环境变量名为ABC

secret名称：mysecret

pod1名称：pod-volume-secret

pod2名称：pod-env-secret

```bash
创建一个 Secret，将其保存为 YAML 文件，例如 my-secret.yaml，并指定需要保密的数据：
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
data:
  username: <Base64编码的用户名>
  password: <Base64编码的密码>
kubectl create -f my-secret.yaml
创建 Pod1，并将 Secret 挂载到 /etc/foo 路径：
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
  - name: my-container
    image: your-image
    # 其他容器配置
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/foo
  volumes:
  - name: secret-volume
    secret:
      secretName: my-secret

创建 Pod2，并使用环境变量引用 Secret 中的值：
apiVersion: v1
kind: Pod
metadata:
  name: pod2
spec:
  containers:
  - name: my-container
    image: your-image
    # 其他容器配置
    env:
    - name: ABC
      valueFrom:
        secretKeyRef:
          name: my-secret
          key: username

分别保存 Pod1 和 Pod2 的 YAML 配置为 pod1.yaml 和 pod2.yaml 文件，并使用以下命令创建这两个 Pod：

kubectl create -f pod1.yaml
kubectl create -f pod2.yaml
```

### 20、 创建一个Pod使用PV自动供给

```bash
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
    - name: my-container
      image: your-image
      # 其他容器配置
      volumeMounts:
        - name: my-pvc-volume
          mountPath: /data
  volumes:
    - name: my-pvc-volume
      persistentVolumeClaim:
        claimName: my-pvc
```

### 21、创建一个pod并挂载数据卷，不可以用持久卷

```bash
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
    - name: my-container
      image: your-image
      # 其他容器配置
      volumeMounts:
        - name: data-volume
          mountPath: /data
  volumes:
    - name: data-volume
      emptyDir: {}
```

### 22、将pv按照名称、容量排序，并保存到/opt/pv文件

```bash
kubectl get pv --sort-by=.metadata.name > /opt/pv
kubectl get pv --sort-by=.spec.capacity.storage > /opt/pv
```

### 23、Etcd数据库备份与恢复（kubeadm）

**备份** ETCDCTL_API=3 etcdctl --endpoints=[https://127.0.0.1:2379](https://127.0.0.1:2379)  
--cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key  
snapshot save snap.db

**还原**

先暂停kube-apiserver和etcd容器

mv /etc/kubernetes/manifests /etc/kubernetes/manifests.bak

ETCDCTL_API=3 etcdctl snapshot restore snap.db --data-dir=/var/lib/etcd

启动kube-apiserver和etcd容器

mv /etc/kubernetes/manifests.bak /etc/kubernetes/manifests

### 24、升级管理节点kubelet ,kubectl 组件由1.18 升级为 1.19 ，工作节点不升级

1、查找最新版本号
yum list --showduplicates kubeadm --disableexcludes=kubernetes
2、升级kubeadm
yum install -y kubeadm-1.19.3-0 --disableexcludes=kubernetes
3、驱逐node上的pod，且不可调度
kubectl drain k8s-master --ignore-daemonsets
4、检查集群是否可以升级，并获取可以升级的版本
kubeadm upgrade plan
5、执行升级
kubeadm upgrade apply v1.19.3
6、取消不可调度
kubectl uncordon k8s-master
7、升级kubelet和kubectl
yum install -y kubelet-1.19.3-0 kubectl-1.19.3-0 --disableexcludes=kubernetes
8、重启kubelet
systemctl daemon-reload
systemctl restart kubelet
9、验证
kubectl get node

### 25、创建一个ingress

```bash
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
    - host: example.com
      http:
        paths:
          - path: /foo
            pathType: Prefix
            backend:
              service:
                name: foo-service
                port:
                  number: 80
          - path: /bar
            pathType: Prefix
            backend:
              service:
                name: bar-service
                port:
                  number: 80
```

### 26、Pod创建一个边车容器读取业务容器日志

```bash
apiVersion: v1
kind: Pod
metadata:
  name: log-counter
spec:
  containers:
  - name: web
    image: busybox
    command: ["/bin/sh","-c","for i in $(seq 1 100);do echo $i >> /var/log/access.log;sleep
    1;done"]
    volumeMounts:
      - name: varlog
        mountPath: /var/log
  - name: log
    image: busybox
    command: ["/bin/sh","-c","tail -f /var/log/access.log"]
    volumeMounts:
      - name: varlog
        mountPath: /var/log
  volumes:
  - name: varlog
    emptyDir: {} 
```

### 27、创建一个clusterrole，关联到一个服务账号

```bash
# 创建用户
$ kubectl create serviceaccount dashboard-admin -n kube-system
# 用户授权
$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --
serviceaccount=kube-system:dashboard-admin
```

### 28、default命名空间下所有pod可以互相访问，也可以 访问其他命名空间Pod，但其他命名空间不能访问default 命名空间Pod

```bash
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-from-other-namespaces
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Ingress
    ingress:
  - from:
    - podSelector: {}
podSelector: {}：default命名空间下所有Pod
from.podSelector: {} : 如果未配置具体的规则，默认不允许
```
