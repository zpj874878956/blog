(window.webpackJsonp=window.webpackJsonp||[]).push([[356],{709:function(r,e,a){"use strict";a.r(e);var t=a(0),s=Object(t.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("p",[e("strong",[r._v("一、磁盘")]),e("br"),r._v(" "),e("strong",[r._v("1、告警：Disk read/write request responses are too high")]),e("br"),r._v("\n表达式解释为:"),e("br"),r._v("\n最近15分钟的对应磁盘的Disk read request avg waiting time (r_await)大于20ms或者 Disk write request avg waiting time (w_await) 大于20ms")]),r._v(" "),e("p",[r._v("min(/Linux block devices by Zabbix agent/vfs.dev.read.await[{#DEVNAME}],15m) > {KaTeX parse error: Expected '}', got '#' at position 27: …D.AWAIT.WARN:\"{#̲DEVNAME}\"} or m…VFS.DEV.WRITE.AWAIT.WARN:“{#DEVNAME}”}")]),r._v(" "),e("p",[e("strong",[r._v("解决方案")]),e("br"),r._v("\na、模板Linux block devices by Zabbix agent 中的提高宏 {KaTeX parse error: Expected 'EOF', got '}' at position 24: …READ.AWAIT.WARN}̲ 和 宏 {VFS.DEV.WRITE.AWAIT.WARN} 的值 默认是20。"),e("br"),r._v("\nb、上SSD系统盘、大容量数据盘。"),e("br"),r._v("\nc、以上两种方法只能解决提示，但解决为何读写高的问题才是根本。")]),r._v(" "),e("h1",{attrs:{id:"查读写io进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查读写io进程"}},[r._v("#")]),r._v(" 查读写io进程")]),r._v(" "),e("p",[r._v("iotop")]),r._v(" "),e("h1",{attrs:{id:"查io高的pid和进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查io高的pid和进程"}},[r._v("#")]),r._v(" 查io高的pid和进程")]),r._v(" "),e("p",[r._v("pidstat -d 1 10")]),r._v(" "),e("p",[e("strong",[r._v("二、数据库相关(Mysql,MariaDB)")]),e("br"),r._v(" "),e("strong",[r._v("1、告警：MySQL: Replication lag is too high (over 30m for 5m)")]),e("br"),r._v("\nSeconds_Behind_Master时长超过1800秒，具体实际情况进行恢复主从延迟即可。")]),r._v(" "),e("p",[e("strong",[r._v("2、告警：MySQL: Buffer pool utilization is too low (less 50% for 5m)")]),e("br"),r._v("\n由于分配了比实际需要更多的 RAM。结合实际情况，降低其严重性即可。"),e("br"),r._v("\n因为对存储服务器分配更多的RAM在合理计划范围内、增加缓冲池字节大小有利于提高性能。"),e("br"),r._v("\nMysql官网innodb_buffer_pool_size参数详解")]),r._v(" "),e("p",[e("strong",[r._v("三、Zabbix Server相关")]),e("br"),r._v(" "),e("strong",[r._v("1、告警：More than 100 items having missing data for more than 10 minutes")]),e("br"),r._v("\n为轮询器的数量不足以监控监控项")]),r._v(" "),e("p",[e("strong",[r._v("解决方案")]),e("br"),r._v("\nStartPollers 轮询器实例数量。根据具体情况设置大小，默认为5"),e("br"),r._v("\n修改zabbix_server.conf中StartPollers=5为StartPollers=100。")]),r._v(" "),e("p",[e("strong",[r._v("2、告警：Zabbix poller processes more than 75% busy")]),e("br"),r._v("\nunreachable poller processes 一直在处于busy的状态，那这个具体代表什么意思呢，查看官方文档zabbix internal process、unreachable poller - poller for unreachable devices 用于轮询不可到达到的设备。"),e("br"),r._v(" "),e("strong",[r._v("可能情况：")])]),r._v(" "),e("p",[r._v("通过Zabbix agent采集数据的设备处于moniting的状态但是此时机器死机或其他原因导致zabbix agent死掉server获取不到数据，此时unreachable poller就会升高。"),e("br"),r._v("\n通过Zabbix agent采集数据的设备处于moniting的状态但是server向agent获取数据时时间过长，经常超过server设置的timeout时间，此时unreachable poller就会升高。"),e("br"),r._v("\n支撑Zabbix的MySQL卡住了，Zabbix服务器的IO卡住了都有可能，Zabbix进程分配到内存不足都有可能。"),e("br"),r._v("\n一个简单的方法是增加Zabbix Server启动时初始化的进程数量，这样直接增加了轮询的负载量，从比例上来讲忙的情况就少了。"),e("br"),r._v(" "),e("strong",[r._v("解决方案")])]),r._v(" "),e("p",[r._v("CacheSize:缓存大小, 单位字节.用于存储主机、监控项、触发器数据的共享内存大小。\n修改zabbix_server.conf中CacheSize=8M为CacheSize=2048M。")]),r._v(" "),e("p",[e("strong",[r._v("3、告警Zabbix server: Zabbix value cache working in low memory mode")])]),r._v(" "),e("p",[e("strong",[r._v("解决方案")])]),r._v(" "),e("p",[r._v("修改zabbix_server.conf配置的ValueCacheSize=2048M")]),r._v(" "),e("p",[e("strong",[r._v("四、Redis相关")]),e("br"),r._v(" "),e("strong",[r._v("1、告警：Redis: Memory fragmentation ratio is too high (over 1.5 in 15m)")]),e("br"),r._v("\n内存碎片率：mem_fragmentation_ratio = used_memory_rss / used_memory"),e("br"),r._v("\nused_memory ：Redis使用其分配器分配的内存大小"),e("br"),r._v("\nused_memory_rss ：操作系统分配给Redis实例的内存大小，表示该进程所占物理内存的大小"),e("br"),r._v("\n两者包括了实际缓存占用的内存和Redis自身运行所占用的内存，used_memory_rss指标还包含了内存碎片的开销，内存碎片是由操作系统低效的分配/回收物理内存导致的。"),e("br"),r._v("\nmem_fragmentation_ratio < 1 表示Redis内存分配超出了物理内存，操作系统正在进行内存交换，内存交换会引起非常明显的响应延迟；"),e("br"),r._v("\nmem_fragmentation_ratio > 1 是合理的；"),e("br"),r._v("\nmem_fragmentation_ratio > 1.5 说明Redis消耗了实际需要物理内存的150%以上，其中50%是内存碎片率，可"),e("br"),r._v("\n内存碎片率略高于1是属于正常，但超出1.5的时候就说明redis的内存管理变差了"),e("br"),r._v("\n分析实际环境，因为该redis主要是存储频繁更新的数据，每次更新数据之前，redis会删除旧的数据，实际上，由于Redis释放了内存块，但内存分配器并没有返回内存给操作系统。")]),r._v(" "),e("p",[e("strong",[r._v("解决方案")]),e("br"),r._v("\n开启碎片整理为redis.conf中，修改# activedefrag no为activedefrag yes。")]),r._v(" "),e("h1",{attrs:{id:"开启碎片整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开启碎片整理"}},[r._v("#")]),r._v(" 开启碎片整理")]),r._v(" "),e("p",[r._v("activedefrag yes")]),r._v(" "),e("h1",{attrs:{id:"当碎片达到-100mb-时-开启内存碎片整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#当碎片达到-100mb-时-开启内存碎片整理"}},[r._v("#")]),r._v(" 当碎片达到 100mb 时，开启内存碎片整理")]),r._v(" "),e("p",[r._v("#active-defrag-ignore-bytes 100mb")]),r._v(" "),e("h1",{attrs:{id:"当碎片超过-10-时-开启内存碎片整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#当碎片超过-10-时-开启内存碎片整理"}},[r._v("#")]),r._v(" 当碎片超过 10% 时，开启内存碎片整理")]),r._v(" "),e("p",[r._v("#active-defrag-threshold-lower 10")]),r._v(" "),e("h1",{attrs:{id:"内存碎片超过-100-则尽最大努力整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片超过-100-则尽最大努力整理"}},[r._v("#")]),r._v(" 内存碎片超过 100%，则尽最大努力整理")]),r._v(" "),e("p",[r._v("active-defrag-threshold-upper 100")]),r._v(" "),e("h1",{attrs:{id:"内存自动整理占用资源最小百分比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存自动整理占用资源最小百分比"}},[r._v("#")]),r._v(" 内存自动整理占用资源最小百分比")]),r._v(" "),e("p",[r._v("active-defrag-cycle-min 25")]),r._v(" "),e("h1",{attrs:{id:"内存自动整理占用资源最大百分比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存自动整理占用资源最大百分比"}},[r._v("#")]),r._v(" # 内存自动整理占用资源最大百分比")]),r._v(" "),e("p",[r._v("active-defrag-cycle-max 75")]),r._v(" "),e("p",[e("strong",[r._v("2、衍生问题①：开启内存碎片整理activedefrag yes报错(error)")]),e("br"),r._v("\nERR Active defragmentation cannot be enabled: it requires a Redis server compiled with a modified Jemalloc like the one shipped by default with the Redis source distribution")]),r._v(" "),e("p",[r._v("这个内存分配器是在编译时指定的，可以是libc、jemalloc或者tcmalloc。used_memory_rss会越来越大，导致mem_fragmentation_ratio越来越高")]),r._v(" "),e("p",[e("strong",[r._v("解决方案")]),e("br"),r._v("\n因编译的时候内存分配器非jemalloc，需要重新使用jemalloc编译。编译以后问题解决。")]),r._v(" "),e("p",[e("strong",[r._v("3、衍生问题②：即使开启自动碎片整理后，仍然会告警。")]),e("br"),r._v("\n解决方案"),e("br"),r._v("\n考虑提高阈值。")]),r._v(" "),e("p",[r._v("性能相关"),e("br"),r._v(" "),e("strong",[r._v("4、告警：sda: Disk read/write request responses are too high (read > 20 ms for 15m or write > 20 ms for 15m)")]),e("br"),r._v("\n装有Clickhouse服务器A1、A2、S1、S2磁盘写入等待时间高于默认20ms")]),r._v(" "),e("p",[e("img",{attrs:{src:"http://pic.zzppjj.top/LightPicture/2023/03/4fe54c88c7d23065.png",alt:""}})]),r._v(" "),e("p",[r._v("r_await：每个读操作平均所需的时间=[Δrd_ticks/Δrd_ios]"),e("br"),r._v("\n不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间。"),e("br"),r._v("\nw_await：每个写操作平均所需的时间=[Δwr_ticks/Δwr_ios]"),e("br"),r._v("\n不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间。")]),r._v(" "),e("p",[r._v("解决方案（暂未解决）"),e("br"),r._v("\n根据读r_await基本没有延迟。")]),r._v(" "),e("p",[r._v("可能是clikchouse数据库特性导致，考虑优化clickhouse配置。"),e("br"),r._v("\n或者修改连接clickhouse程序代码高频低量写入改为流式写入。")])])}),[],!1,null,null,null);e.default=s.exports}}]);